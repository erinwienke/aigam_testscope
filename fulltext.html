<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Full Text – AIGAM Test</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
<nav>
    <a href="index.html">Home</a>
    <a href="scope.html">Test Scope</a>
    <a href="plan.html">Test Plan</a>
    <a href="phaseone.html">Phase 1: Backend Integration + External Systems</a>
    <a href="phasetwo.html">Phase 2: Middleware Integration</a>
    <a href="phasethree.html">Phase 3: Frontend Integration</a>
    <a href="phasefour.html">Phase 4: Validation + Full System</a>
    <a href="fulltext.html">Full Text</a>
</nav>
<div class="container">
    <h1>AIGAM Test</h1>
    <h2>Full Text</h2>

    <div id="testScope"></div>
    <div id="testPlan"></div>
    <div id="phase1"></div>
    <div id="phase2"></div>
    <div id="phase3"></div>
    <div id="phase4"></div>

<script>
  const includes = [
    { file: 'scope.html',     elementId: 'testScope', elevate: true  },
    { file: 'plan.html',      elementId: 'testPlan',  elevate: true  },
    { file: 'phaseone.html',  elementId: 'phase1',    elevate: false },
    { file: 'phasetwo.html',  elementId: 'phase2',    elevate: false },
    { file: 'phasethree.html',elementId: 'phase3',    elevate: false },
    { file: 'phasefour.html', elementId: 'phase4',    elevate: false },
  ];

  // Track which H1 texts we’ve already used (by text)
  const seenH1Headings = new Set();

  // OPTIONAL: treat existing H1s in fulltext.html as “first”
  document.querySelectorAll("h1").forEach(h => {
    const key = h.textContent.trim();
    if (key) seenH1Headings.add(key);
  });

  async function loadSectionsSequentially() {
    for (const { file, elementId, elevate } of includes) {
      try {
        const res = await fetch(file);
        const html = await res.text();

        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");

        const container = doc.querySelector(".container");
        if (!container) {
          console.warn(`${file} has no .container div`);
          continue;
        }

        const clone = container.cloneNode(true);

        // 1️⃣ Remove only duplicate H1s (first occurrence wins)
        clone.querySelectorAll("h1").forEach(h => {
          const key = h.textContent.trim();
          if (!key) return;

          if (seenH1Headings.has(key)) {
            h.remove();         // seen before → drop it
          } else {
            seenH1Headings.add(key);  // first time → keep it
          }
        });

        // 2️⃣ Elevate headings only for scope + plan
        if (elevate) {
          const headings = Array.from(
            clone.querySelectorAll("h1, h2, h3, h4, h5, h6")
          );

          if (headings.length > 0) {
            const minLevel = Math.min(
              ...headings.map(h => parseInt(h.tagName[1], 10))
            );

            const shift = minLevel - 1; // e.g. top is h2 ⇒ shift = 1

            if (shift > 0) {
              headings.forEach(h => {
                const oldLevel = parseInt(h.tagName[1], 10);
                let newLevel = Math.max(1, oldLevel - shift);

                const newTag = document.createElement("h" + newLevel);

                // Copy attributes
                for (const attr of h.attributes) {
                  newTag.setAttribute(attr.name, attr.value);
                }
                newTag.innerHTML = h.innerHTML;

                h.replaceWith(newTag);
              });
            }
          }
        }

        // 3️⃣ Inject processed HTML into the page
        document.getElementById(elementId).innerHTML = clone.innerHTML;
      } catch (err) {
        console.error(`Error loading ${file}:`, err);
      }
    }
  }

  loadSectionsSequentially();
</script>
</div>
</body>

</html>

